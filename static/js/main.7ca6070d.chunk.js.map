{"version":3,"sources":["lib/map.js","components/App.js","serviceWorker.js","index.js"],"names":["_directions","x","y","generateDungeon","width","height","rooms","windiness","data","push","Array","fill","regions","region","incrementRegion","carveRegion","pos","value","my","length","mx","_addRooms","_createMaze","_connectRegions","_removeDeadEnds","numRoomTries","roomSize","Math","max","min","i","size","_range","rectangularity","room","overlaps","j","_isOverlapped","xOffset","yOffset","start","lastDir","cells","cell","posCells","dir","_canCarve","c1","_addDir","includes","random","floor","c2","pop","_carve","connectors","connectedRegions","merged","openRegions","index","connector","map","dest","sources","slice","filter","con","abs","_fill","done","exits","_isInBounds","nxt","len","pri","sec","App","props","onResize","bind","onAnimationFrame","onClick","state","this","_resizeViewport","window","addEventListener","frame","requestAnimationFrame","removeEventListener","cancelAnimationFrame","_drawMap","setState","canvas","rect","getBoundingClientRect","ctx","getContext","fillStyle","fillRect","cellWidth","cellHeight","className","id","ref","elem","React","Component","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.7ca6070d.chunk.js","sourcesContent":["const _directions = [\r\n  { x: -1, y: 0 },\r\n  { x: 0, y: -1 },\r\n  { x: 1, y: 0 },\r\n  { x: 0, y: 1 }\r\n];\r\n\r\n// based on this article https://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/\r\nexport function generateDungeon(width, height, rooms, windiness = 0.8) {\r\n  const data = [];\r\n  for (let y = 0; y < height; y++) {\r\n    data.push(new Array(width).fill(1));\r\n  }\r\n\r\n  const regions = [];\r\n  let region = 0;\r\n\r\n  const incrementRegion = () => {\r\n    region++;\r\n  }\r\n\r\n  const carveRegion = (data, pos, value) => {\r\n    data[pos.y][pos.x] = value;\r\n    regions[pos.y][pos.x] = region;\r\n  }\r\n\r\n  const my = data.length;\r\n  const mx = data[0].length;\r\n  for (let y = 0; y < my; y++) {\r\n    regions.push(Array(mx).fill(0))\r\n  }\r\n\r\n  _addRooms(data, mx, my, incrementRegion, carveRegion, rooms, 2);\r\n\r\n  for (let y = 1; y < my; y += 2) {\r\n    for (let x = 1; x < mx; x += 2) {\r\n      if (data[y][x] !== 1) {\r\n        continue;\r\n      }\r\n\r\n      region++;\r\n\r\n      _createMaze(data, carveRegion, { x, y }, windiness);\r\n    }\r\n  }\r\n\r\n  _connectRegions(data, mx, my, region, regions);\r\n\r\n  _removeDeadEnds(data, mx, my);\r\n\r\n  return {\r\n    width,\r\n    height,\r\n    data\r\n  };\r\n}\r\n\r\nfunction _addRooms(data, mx, my, incrementRegion, carveRegion, numRoomTries) {\r\n  const roomSize = Math.max(Math.min(mx / 10, my / 10), 1);\r\n  const rooms = [];\r\n  for (let i = 0; i < numRoomTries; i++) {\r\n    const size = (_range(Math.max(1, roomSize / 2), roomSize) << 1) + 1;\r\n    let rectangularity = _range(0, size >> 1) << 1;\r\n    let width = size;\r\n    let height = size;\r\n    if (_range(0, 1) === 0) {\r\n      if (width + rectangularity < mx / 2) {\r\n        width += rectangularity;\r\n      }\r\n    } else {\r\n      if (height + rectangularity < my / 2) {\r\n        height += rectangularity;\r\n      }\r\n    }\r\n    let x = (_range(0, (mx - width - 1) >> 1) << 1) + 1;\r\n    let y = (_range(0, (my - height - 1) >> 1) << 1) + 1;\r\n    if (x + width > mx - 1 || y + height > my - 1) {\r\n      continue;\r\n    }\r\n    const room = { x, y, width, height };\r\n    let overlaps = false;\r\n    for (let j = 0; j < rooms.length; j++) {\r\n      const other = rooms[j];\r\n      if (_isOverlapped(room, other)) {\r\n        overlaps = true;\r\n        break;\r\n      }\r\n    }\r\n    if (overlaps) {\r\n      continue;\r\n    }\r\n    rooms.push(room);\r\n    incrementRegion();\r\n    for (let xOffset = 0; xOffset < width; xOffset++) {\r\n      for (let yOffset = 0; yOffset < height; yOffset++) {\r\n        carveRegion(data, { x: x + xOffset, y: y + yOffset }, 2);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction _createMaze(data, carveRegion, start, windiness) {\r\n  const my = data.length;\r\n  const mx = data[0].length;\r\n  const cells = [];\r\n  let lastDir;\r\n  carveRegion(data, start, 0);\r\n  data[start.y][start.x] = 0;\r\n  cells.push(start);\r\n  while (cells.length > 0) {\r\n    const cell = cells[cells.length - 1];\r\n    const posCells = [];\r\n    for (let i = 0; i < _directions.length; i++) {\r\n      const dir = _directions[i];\r\n      if (_canCarve(data, mx, my, cell, dir)) {\r\n        posCells.push(dir);\r\n      }\r\n    }\r\n    if (posCells.length > 0) {\r\n      let dir;\r\n      if (posCells.includes(lastDir) && Math.random() > windiness) {\r\n        dir = lastDir;\r\n      } else {\r\n        dir = posCells[Math.floor(Math.random() * posCells.length)];\r\n      }\r\n      const c1 = _addDir(cell, dir, 1);\r\n      const c2 = _addDir(cell, dir, 2);\r\n      carveRegion(data, c1, 0);\r\n      carveRegion(data, c2, 0);\r\n      cells.push(_addDir(cell, dir, 2));\r\n      lastDir = dir;\r\n    } else {\r\n      cells.pop();\r\n      lastDir = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction _connectRegions(data, mx, my, region, regions) {\r\n  function _carve(data, pos) {\r\n    data[pos.y][pos.x] = 0;\r\n  }\r\n\r\n  let connectors = [];\r\n  for (let y = 1; y < my - 1; y++) {\r\n    for (let x = 1; x < mx - 1; x++) {\r\n      if (data[y][x] !== 1) {\r\n        continue;\r\n      }\r\n      const connectedRegions = [];\r\n      for (let i = 0; i < _directions.length; i++) {\r\n        const dir = _directions[i];\r\n        const region = regions[y + dir.y][x + dir.x];\r\n        if (region !== 0 && !connectedRegions.includes(region)) {\r\n          connectedRegions.push(region);\r\n        }\r\n      }\r\n      if (connectedRegions.length < 2) {\r\n        continue;\r\n      }\r\n      connectors.push({ x, y, regions: connectedRegions })\r\n    }\r\n  }\r\n  const merged = [0];\r\n  let openRegions = [];\r\n  for (var i = 1; i <= region; i++) {\r\n    merged.push(i);\r\n    openRegions.push(i);\r\n  }\r\n  while (openRegions.length > 1 && connectors.length > 0) {\r\n    const index = _range(0, connectors.length - 1)\r\n    const connector = connectors[index];\r\n    _carve(data, { x: connector.x, y: connector.y });\r\n    const regions = connector.regions.map((region) => merged[region]);\r\n    const dest = regions[0];\r\n    const sources = regions.slice(1);\r\n    for (let i = 0; i <= region; i++) {\r\n      if (sources.includes(i)) {\r\n        merged[i] = dest;\r\n      }\r\n    }\r\n    openRegions = openRegions.filter((region) => {\r\n      return !sources.includes(region);\r\n    });\r\n    connectors = connectors.filter((con) => {\r\n      if (Math.abs(con.x - connector.x) <= 1 && Math.abs(con.y - connector.y) <= 1) {\r\n        return false;\r\n      }\r\n      con.regions = con.regions.map((region) => merged[region]);\r\n      for (let i = 1; i < con.regions.length; i++) {\r\n        if (con.regions[i] !== con.regions[0]) {\r\n          return true;\r\n        }\r\n      }\r\n      if (_range(0, 99) === 0) {\r\n        _carve(data, { x: con.x, y: con.y });\r\n      }\r\n      return false;\r\n    });\r\n  }\r\n}\r\n\r\nfunction _removeDeadEnds(data, mx, my) {\r\n  function _fill(data, pos) {\r\n    data[pos.y][pos.x] = 1;\r\n  }\r\n\r\n  let done = false;\r\n  while (!done) {\r\n    done = true;\r\n    for (let y = 1; y < my - 1; y++) {\r\n      for (let x = 1; x < mx - 1; x++) {\r\n        if (data[y][x] === 1) {\r\n          continue;\r\n        }\r\n        let exits = 0;\r\n        for (let i = 0; i < _directions.length; i++) {\r\n          const dir = _directions[i];\r\n          if (data[y + dir.y][x + dir.x] !== 1) {\r\n            exits++;\r\n          }\r\n        }\r\n        if (exits !== 1) {\r\n          continue;\r\n        }\r\n        done = false;\r\n        _fill(data, { x, y });\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction _canCarve(data, mx, my, pos, dir) {\r\n  if (!_isInBounds(mx, my, _addDir(pos, dir, 3))) {\r\n    return false;\r\n  }\r\n  const nxt = _addDir(pos, dir, 2);\r\n  return data[nxt.y][nxt.x] === 1;\r\n}\r\n\r\nfunction _isInBounds(mx, my, pos) {\r\n  if (pos.x < 0 || pos.y < 0 || pos.x >= mx || pos.y >= my) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction _addDir(pos, dir, len) {\r\n  return {\r\n    x: pos.x + dir.x * len,\r\n    y: pos.y + dir.y * len\r\n  }\r\n}\r\n\r\nfunction _range(min, max) {\r\n  const value = Math.floor(Math.random() * (max - min + 1)) + min;\r\n  return value;\r\n}\r\n\r\nfunction _isOverlapped(pri, sec) {\r\n  if (pri.x > sec.x + sec.width || sec.x > pri.x + pri.width) {\r\n    return false;\r\n  }\r\n  if (pri.y > sec.y + sec.height || sec.y > pri.y + pri.height) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n","import React from 'react';\nimport { generateDungeon } from '../lib/map';\n\n// Take Home Projects - Build a Roguelike Dungeon Crawler Game\n// Objective: Build a CodePen.io app that is functionally similar to this: https://codepen.io/freeCodeCamp/full/apLXEJ/.\n// Fulfill the below user stories. Use whichever libraries or APIs you need. Give it your own personal style.\n// User Story: I have health, a level, and a weapon. I can pick up a better weapon. I can pick up health items.\n// User Story: All the items and enemies on the map are arranged at random.\n// User Story: I can move throughout a map, discovering items.\n// User Story: I can move anywhere within the map's boundaries, but I can't move through an enemy until I've beaten it.\n// User Story: Much of the map is hidden. When I take a step, all spaces that are within a certain number of spaces from me are revealed.\n// User Story: When I beat an enemy, the enemy goes away and I get XP, which eventually increases my level.\n// User Story: When I fight an enemy, we take turns damaging each other until one of us loses. I do damage based off of my level and my weapon. The enemy does damage based off of its level. Damage is somewhat random within a range.\n// User Story: When I find and beat the boss, I win.\n// User Story: The game should be challenging, but theoretically winnable.\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.onResize = this.onResize.bind(this);\n    this.onAnimationFrame = this.onAnimationFrame.bind(this);\n    this.onClick = this.onClick.bind(this);\n    this.state = {\n      map: generateDungeon(101, 53, 1000)\n    };\n  }\n\n  componentDidMount() {\n    this._resizeViewport();\n    window.addEventListener('resize', this.onResize);\n    this.frame = window.requestAnimationFrame(this.onAnimationFrame);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.onResize);\n    window.cancelAnimationFrame(this.frame);\n  }\n\n  onResize() {\n    this._resizeViewport();\n  }\n\n  onAnimationFrame() {\n    this._drawMap();\n    this.frame = window.requestAnimationFrame(this.onAnimationFrame);\n  }\n\n  onClick() {\n    this.setState({\n      map: generateDungeon(101, 53, 1000)\n    });\n  }\n\n  _resizeViewport() {\n    const canvas = this.canvas;\n    const rect = canvas.getBoundingClientRect()\n    canvas.width = rect.width;\n    canvas.height = rect.height;\n  }\n\n  _drawMap() {\n    const { width, height, data } = this.state.map;\n    const ctx = this.canvas.getContext('2d');\n    ctx.fillStyle = '#FFFFFF';\n    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    ctx.fillStyle = '#000000';\n    const cellWidth = Math.floor(this.canvas.width / width);\n    const cellHeight = Math.floor(this.canvas.height / height);\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        if (data[y][x] !== 1) {\n          ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);\n        }\n      }\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"screen\">\n        <canvas id=\"canvas\" ref={elem => this.canvas = elem} onClick={this.onClick}></canvas>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}